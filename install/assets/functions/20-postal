#!/usr/bin/with-contenv /bin/bash

bootstrap() {
  mkdir -p ${CONFIG_PATH}
  if [ ! -f "${CONFIG_PATH}"/"${SIGNING_KEY_FILE}" ]; then
            print_notice "Creating Signing Private Key"
            silent openssl genrsa -out $"${CONFIG_PATH}"/"${SIGNING_KEY_FILE}" ${SIGNING_KEY_BITS}
            chmod 644 "${CONFIG_PATH}"/"${SIGNING_KEY_FILE}"
  fi
}

certificates() {
  CA_NAME=postal-selfsigned-ca
  CA_SUBJECT=${CA_SUBJECT:-"/C=XX/ST=Postal/L=Postal/O=Postal/CN="}
  CA_CERT_SUBJECT=${CA_CERT_SUBJECT:-${CA_SUBJECT}${CA_NAME}}
  CA_CERT_FILE=${CA_CERT_FILE:-"/certs/${CA_NAME}/${CA_NAME}.crt"}
  CA_KEY_FILE=${CA_KEY_FILE:-"$(dirname ${CA_CERT_FILE})/${CA_NAME}.key"}
  CREATE_CA=${CREATE_CA:-"TRUE"}

  certificates_create_certificate_authority() {
    if [ ! -f ${CA_CERT_FILE} ] ; then

      print_debug "Certificates: Creating Self Signed Certificate Authority"
      mkdir -p $(dirname ${CA_CERT_FILE})
      echo "000a" > $(dirname ${CA_CERT_FILE})/serial
      touch $(dirname ${CA_CERT_FILE})/certindex

      silent eval "openssl req \
            -newkey rsa:4096 -keyout ${CA_KEY_FILE} \
            -x509 -days 3650 -nodes -out ${CA_CERT_FILE} \
            -subj \"${CA_CERT_SUBJECT}\""

      cat > $(dirname ${CA_CERT_FILE})/$CA_NAME.conf << EOF
      [ ca ]
    t_ca = $CA_NAME

      [ $CA_NAME ]
      unique_subject = no
      new_certs_dir = .
      certificate = ${CA_CERT_FILE}
      database = $(dirname ${CA_CERT_FILE})/certindex
      private_key = ${CA_KEY_FILE}
      serial = $(dirname ${CA_CERT_FILE})/serial
      default_days = 3650
      default_md = default
      policy = ${CA_NAME}_policy
      x509_extensions = ${CA_NAME}_extensions

      [ ${CA_NAME}_policy ]
      commonName = supplied
      stateOrProvinceName = supplied
      countryName = supplied
      emailAddress = optional
      organizationName = supplied
      organizationalUnitName = optional

      [ ${CA_NAME}_extensions ]
      basicConstraints = CA:false
      subjectKeyIdentifier = hash
      authorityKeyIdentifier = keyid:always
      keyUsage = digitalSignature,keyEncipherment
      extendedKeyUsage = serverAuth,clientAuth

      [ req ]
      default_bits    = 2048

      [default_conf]
      ssl_conf = ssl_sect

      [ssl_sect]
      system_default = system_default_sect

      [system_default_sect]
      MinProtocol = TLSv1.1
      MaxProtocol = TLSv1.2
      CipherString = DEFAULT
EOF
      else
          print_debug "Certificates: CA Already Exists"
    fi
  }

  certificates_create_certificate() {
      if [ "$1" != "" ] ; then

        if var_true "${CREATE_CA}" ; then
            if [ ! -f ${CA_CERT_FILE} ] || [ ! -f ${CA_KEY_FILE} ] ; then
          print_debug "Certificates: No CA Found - Creating before generating certificates"
          certificates_create_certificate_authority
        fi
      fi
            CERT_SUBJECT="${CA_SUBJECT}$(basename ${1%%.*})"

        if var_true $CREATE_CA ; then
        if [ ! -f ${1%%.*}.key ] ; then
          print_debug "Certificates: Creating Certificate: ${1}"
          silent eval "openssl req \
                  -newkey rsa:2048 -keyout ${1%%.*}.key \
                -nodes -out ${1%%.*}.csr \
                -subj \"${CERT_SUBJECT}\""
        fi
      else
        if [ ! -f ${1%%.*}.key ] ; then
          print_debug "Certificates: Creating Certificate: ${1}"
          silent eval "openssl req \
              -new -x509 -nodes -days 3650
              -config /tmp/openssl.cnf
              -out ${1%%.*}.crt \
              -keyout ${1%%.*}.key"
        fi
      fi

        if var_true $CREATE_CA ; then
        if [ ! -f ${1%%.*}.cert ] ; then
          print_debug "Certificates: Signing Certificate: ${1}"
          silent eval "openssl ca -batch -config $(dirname ${CA_CERT_FILE})/${CA_NAME}.conf -notext -in ${1%%.*}.csr -out ${1%%.*}.crt"
          rm -rf $(tail -n 1 $(dirname ${CA_CERT_FILE})/certindex | awk '{print $3}').pem
          rm -rf ${1%%.*}.csr
        fi
      fi

      if [ -f ${1%%.*}.crt ] && [ -f ${1%%.*}.key ] ; then
        print_debug "Certificates: Merging Certificate and Key for: ${1}"
          cat ${1%%.*}.crt ${1%%.*}.key > ${1%%.*}.pem
      fi

      if [ ! -f ${1%%.*}-public.pem ] ; then
        print_debug "Certificates: Creating Public Key for: ${1}"
        silent openssl rsa -in ${1%%.*}.pem -out ${1%%.*}-public.pem -outform PEM -pubout
      fi
    fi
  }

  certificates_check_permissions() {
    if sudo -u postal [ ! -r "${1}" ] ; then
        print_debug "Certificates: Setting Read Permissions on ${1}"
        chmod 444 ${1}
      fi
    }

  certificates_check_certificates() {
    print_debug "Certificates: Checking Existence of ${1}"
    if [ ! -f ${1} ] ; then
          mkdir -p $(dirname ${1})
          certificates_create_certificate ${1}
    fi
  }

  certificates_trust_ca() {
    if var_true "${CREATE_CA}" ; then
      if [ -f ${CA_CERT_FILE} ]; then
        if [ ! -L /usr/local/share/ca-certificates/$(basename ${CA_CERT_FILE}) ] ; then
          print_debug "Certificates: Trusting CA ${CA_NAME}"
          ln -sf ${CA_CERT_FILE} /usr/local/share/ca-certificates/
          silent update-ca-certificates
        fi
      fi
    fi
  }

  case "$1" in
  *)
    certificates_check_certificates ${1}
    certificates_check_permissions ${1}
    certificates_trust_ca
  ;;
  esac
}


check_clamav(){
  print_debug "Checking Clam Antivirus"
  if var_true "${ENABLE_CLAMAV}" ; then
    sanity_var CLAMAV_HOST "ClamAV Host"
    COUNTER=0
    while ! (silent nc -z ${CLAMAV_HOST} ${CLAMAV_PORT}) ; do
        sleep 5
        let COUNTER+=5
        print_warn "ClamAV Host '${CLAMAV_HOST}' is not accessible, retrying.. ($COUNTER seconds so far)"
    done
  fi
}

check_rspamd() {
  print_debug "Checking RSpamD"
  if var_true "${ENABLE_RSPAMD}" ; then
    sanity_var RSPAMD_HOST "RSpamd Host"
    COUNTER=0
    while ! (silent nc -z ${RSPAMD_HOST} ${RSPAMD_PORT}) ; do
        sleep 5
        let COUNTER+=5
        print_warn "RSpamD Host '${RSPAMD_HOST}' is not accessible, retrying.. ($COUNTER seconds so far)"
    done
  fi
}

check_spamassassin() {
  print_debug "Checking Spamassassin"
  if var_true "${ENABLE_SPAMASSASSIN}" ; then
    sanity_var SPAMASSASSIN_HOST "SpamAssassin Host"
    COUNTER=0
    while ! (silent nc -z ${SPAMASSASSIN_HOST} ${SPAMASSASSIN_PORT}) ; do
        sleep 5
        let COUNTER+=5
        print_warn "SpamAssassin Host '${SPAMASSASSIN_HOST}' is not accessible, retrying.. ($COUNTER seconds so far)"
    done
  fi
}

compile_assets() {
  print_info "Compiling Assets"
  cd /app/
  silent sudo -HEu postal POSTAL_SKIP_CONFIG_CHECK=1 RAILS_GROUPS=assets bundle exec rake assets:precompile
  silent sudo -HEu postal touch /app/public/assets/.prebuilt
}

custom_assets() {
  if [ -d /assets/custom ] ; then
    print_warn "Custom Assets Found, Copying over top of Master"
    silent cp -R /assets/custom/* "/app/"
    chown -R postal:postal /app/
  fi

  ## Execute Custom Scripts
  if [ -d /assets/custom-scripts/ ] ; then
    print_warn "Found Custom Scripts to Execute"
    for f in $(find /assets/custom-scripts/ -name \*.sh -type f); do
        print_warn "Running Script ${f}"
        chmod +x "${f}"
        ${f}
    done
  fi
}

configure_logging() {
  print_debug "Configuring Logging"
  mkdir -p "${LOG_PATH}"
  chown -R postal: "${LOG_PATH}"
  ln -sf "${LOG_PATH}" /app/log
    create_logrotate postal-production ${LOG_PATH}/production.log none postal postal
  if [ "${LOG_CONSOLE,,}" = "false" ] ; then
    create_logrotate postal-puma-access ${LOG_PATH}/puma-access.log none postal postal
    create_logrotate postal-puma-error ${LOG_PATH}/puma-error.log none postal postal
    create_logrotate postal-slowdb ${LOG_PATH}/slow_message_db_queries.log none postal postal
    create_logrotate postal-smtp ${LOG_PATH}/smtp_server.log none postal postal
    create_logrotate postal-webhooks ${LOG_PATH}/webhooks.log none postal postal
    create_logrotate postal-worker ${LOG_PATH}/worker.log none postal postal
  fi
}

configure_postal() {
  ### Create Configuration
  if [ "$SETUP_TYPE" = "AUTO" ]; then
    print_notice "Configuring Postal"
    mx_array=$(echo $DNS_MX | tr "," "\n")
      for mx in ${mx_array}
      do
          mx_record=${mx_record}$(cat <<EOF
    - ${mx}

EOF
                                )
      done

    if [ -z "${APP_SECRET}" ] ; then
      rails_secret_key=$(openssl rand -hex 128 | tr -d '\n')
    else
      rails_secret_key=${APP_SECRET}
    fi

    print_debug "Writing Configuration to ${CONFIG_PATH}/${CONFIG_FILE}"
    cat <<EOF > "${CONFIG_PATH}"/"${CONFIG_FILE}"
version: 2

postal:
  web_hostname: postal.example.com
  web_protocol: https
  smtp_hostname: postal.example.com
  use_ip_pools: false
  default_maximum_delivery_attempts: 18
  default_maximum_hold_expiry_days: 7
  default_suppression_list_automatic_removal_days: 30
  default_spam_threshold: 5
  default_spam_failure_threshold: 20
  use_local_ns_for_domain_verification: false
  use_resent_sender_header: true
  signing_key_path: $config-file-root/signing.key
  smtp_relays: []
  trusted_proxies: []
  queued_message_lock_stale_days: 1
  batch_queued_messages: true

web_server:
  default_port: 5000
  default_bind_address: 127.0.0.1
  max_threads: 5

worker:
  default_health_server_port: 9090
  default_health_server_bind_address: 127.0.0.1
  threads: 2

main_db:
  host: localhost
  port: 3306
  username: postal
  password: 
  database: postal
  pool_size: 5
  encoding: utf8mb4

message_db:
  host: localhost
  port: 3306
  username: postal
  password: 
  encoding: utf8mb4
  database_name_prefix: postal

logging:
  rails_log_enabled: false
  sentry_dsn: 
  enabled: true
  highlighting_enabled: false

gelf:
  host: 
  port: 12201
  facility: postal

smtp_server:
  default_port: 25
  default_bind_address: ::
  default_health_server_port: 9091
  default_health_server_bind_address: 127.0.0.1
  tls_enabled: false
  tls_certificate_path: $config-file-root/smtp.cert
  tls_private_key_path: $config-file-root/smtp.key
  tls_ciphers: 
  ssl_version: SSLv23
  proxy_protocol: false
  log_connections: false
  max_message_size: 14
  log_ip_address_exclusion_matcher: 

dns:
  mx_records:
    - mx1.postal.example.com
    - mx2.postal.example.com
  spf_include: spf.postal.example.com
  return_path_domain: rp.postal.example.com
  route_domain: routes.postal.example.com
  track_domain: track.postal.example.com
  helo_hostname: 
  dkim_identifier: postal
  domain_verify_prefix: postal-verification
  custom_return_path_prefix: psrp
  timeout: 5
  resolv_conf_path: /etc/resolv.conf

smtp:
  host: 127.0.0.1
  port: 25
  username: 
  password: 
  authentication_type: login
  enable_starttls: false
  enable_starttls_auto: true
  openssl_verify_mode: peer
  from_name: Postal
  from_address: postal@example.com

rails:
  environment: production
  secret_key: 

rspamd:
  enabled: false
  host: 127.0.0.1
  port: 11334
  ssl: false
  password: 
  flags: 

spamd:
  enabled: false
  host: 127.0.0.1
  port: 783

clamav:
  enabled: false
  host: 127.0.0.1
  port: 2000

smtp_client:
  open_timeout: 30
  read_timeout: 30

migration_waiter:
  enabled: false
  attempts: 120
  sleep_time: 2

oidc:
  enabled: false
  local_authentication_enabled: true
  name: OIDC Provider
  issuer: 
  identifier: 
  secret: 
  scopes:
    - openid,email
  uid_field: sub
  email_address_field: email
  name_field: name
  discovery: true
  authorization_endpoint: 
  token_endpoint: 
  userinfo_endpoint: 
  jwks_uri: 
EOF
  fi

  if [ "${CONFIG_PATH}"/"${CONFIG_FILE}" != "/app/config/postal.yml" ] ; then
    ln -sf "${CONFIG_PATH}"/"${CONFIG_FILE}" /app/config/postal.yml
  fi

  if [ -f "${CONFIG_PATH}"/"${SIGNING_KEY_FILE}" ] && [ ! -f "/app/config/signing.key" ] ; then
    ln -sf "${CONFIG_PATH}"/"${SIGNING_KEY_FILE}" /app/config/signing.key
  fi
}

configure_tls() {
  print_debug "Configuring TLS"
  if var_true "$SMTP_SERVER_ENABLE_TLS" ; then
      certificates ${SMTP_SERVER_TLS_CERT}
  fi
  chown postal:postal ${SMTP_SERVER_TLS_CERT}
  chown postal:postal ${SMTP_SERVER_TLS_KEY}
}

initialize_database() {
  print_debug "Initializing Database"
  cd /app/
  silent sudo -HEu postal bundle exec rake db:create db:schema:load db:seed

  mysql -uroot -p$DB_ROOT_PASS -h$DB_HOST -e 'GRANT ALL PRIVILEGES ON `'$DB_NAME'-%` . * to `'$DB_USER'`@`%`  IDENTIFIED BY "'$DB_PASS'";'
  print_notice "Creating Administrative User"
  if [ ! -n "${ADMIN_EMAIL}" ]; then
    print_warn "No Admin Email entered, setting default email login to 'postal@example.com'"
    ADMIN_EMAIL="postal@example.com"
  fi
  if [ ! -n "${ADMIN_PASS}" ]; then
    print_warn "WARNING: No Admin Pass entered, setting default password to 'PostalMailServer'"
    ADMIN_PASS="PostalMailServer"
  fi
  if [ ! -n "${ADMIN_FNAME}" ]; then
    print_warn "No Admin First Name entered, setting default to 'Postal'"
    ADMIN_FNAME="Postal"
  fi
  if [ ! -n "${ADMIN_LNAME}" ]; then
    print_warn "No Admin Last Name entered, setting default to 'Admin'"
    ADMIN_LNAME="Admin"
  fi

  cat <<EOF > /tmp/create-pass.sh
#!/usr/bin/expect

spawn /usr/bin/with-contenv bash /app/bin/postal make-user
expect "E-Mail Address      :"
send -- "$ADMIN_EMAIL\n"
expect "First Name          :"
send -- "$ADMIN_FNAME\n"
expect "Last Name           :"
send -- "$ADMIN_LNAME\n"
expect "Initial Password:   :"
send -- "$ADMIN_PASS\n"
expect "User has been created"
exit 0
EOF

  chmod +x /tmp/create-pass.sh
  print_debug "Creating User"
  silent /tmp/create-pass.sh
  rm -rf /tmp/create-pass.sh
}
